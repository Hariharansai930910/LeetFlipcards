<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LeetCode Flashcards</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    /* Custom styles for 3D flip effect */
    .flip-card-container {
      perspective: 1000px;
    }
    
    .flip-card {
      position: relative;
      width: 100%;
      height: 100%;
      transition: transform 0.6s;
      transform-style: preserve-3d;
    }
    
    .flip-card.flipped {
      transform: rotateY(180deg);
    }
    
    .flip-card-front,
    .flip-card-back {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      overflow: hidden;
    }
    
    .flip-card-front {
      background-color: white;
      z-index: 2;
    }
    
    .flip-card-back {
      background-color: #2d3748;
      color: white;
      transform: rotateY(180deg);
    }
    
    .tab-content {
      height: calc(100% - 120px);
      overflow-y: auto;
    }

    /* Scrollbar styling */
    .tab-content::-webkit-scrollbar {
      width: 6px;
    }
    
    .tab-content::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.1);
      border-radius: 3px;
    }
    
    .tab-content::-webkit-scrollbar-thumb {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 3px;
    }
    
    .tab-content::-webkit-scrollbar-thumb:hover {
      background: rgba(0, 0, 0, 0.4);
    }

    /* Code formatting */
    pre {
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    /* Custom animation for loading */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .fade-in {
      animation: fadeIn 0.5s ease-in;
    }
  </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col">
  <!-- Header -->
  <header class="bg-gray-800 text-white shadow-md">
    <div class="container mx-auto py-4 px-6 flex items-center justify-between">
      <h1 class="text-2xl font-bold">LeetCode Flashcards</h1>
      <button id="backToTopics" class="hidden bg-gray-700 hover:bg-gray-600 px-3 py-1 rounded flex items-center gap-2 transition">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="1 4 1 10 7 10"></polyline>
          <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
        </svg>
        Back to Topics
      </button>
    </div>
  </header>

  <!-- Main Content -->
  <main class="flex-grow container mx-auto p-6">
    <!-- Topic Selection Screen -->
    <div id="topicSelection" class="fade-in">
      <h2 class="text-xl font-semibold mb-6">Select a Topic</h2>
      <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4" id="topicGrid">
        <!-- Topics will be populated here -->
      </div>
    </div>

    <!-- Flashcard Screen (Initially Hidden) -->
    <div id="flashcardScreen" class="hidden fade-in">
      <div class="w-full max-w-3xl mx-auto mb-6">
        <h2 id="currentTopic" class="text-xl font-semibold"></h2>
        <div class="flex justify-between items-center mt-2">
          <p id="problemCounter" class="text-gray-600"></p>
          <div class="flex gap-2">
            <button id="prevButton" class="flex items-center gap-1 px-3 py-1 bg-gray-200 rounded disabled:opacity-50 disabled:cursor-not-allowed">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="15 18 9 12 15 6"></polyline>
              </svg>
              Prev
            </button>
            <button id="nextButton" class="flex items-center gap-1 px-3 py-1 bg-gray-200 rounded disabled:opacity-50 disabled:cursor-not-allowed">
              Next
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="9 18 15 12 9 6"></polyline>
              </svg>
            </button>
          </div>
        </div>
      </div>

      <!-- Flashcard Container -->
      <div class="flip-card-container w-full max-w-3xl aspect-square mx-auto">
        <div id="flashcard" class="flip-card">
          <!-- Front of Card -->
          <div class="flip-card-front rounded-xl shadow-lg">
            <div class="p-5 bg-blue-600 text-white flex justify-between items-center">
              <h3 id="cardTitle" class="font-bold text-xl"></h3>
              <span id="cardDifficulty" class="px-2 py-1 rounded-full text-xs font-semibold"></span>
            </div>
            
            <!-- Front Tabs -->
            <div class="border-b">
              <div class="flex">
                <button id="questionTab" class="px-4 py-2 border-b-2 border-blue-500 text-blue-600 flex items-center gap-2">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="4 17 10 11 4 5"></polyline>
                    <line x1="12" y1="19" x2="20" y2="19"></line>
                  </svg>
                  Question
                </button>
                <button id="hintTab" class="px-4 py-2 border-b-2 border-transparent flex items-center gap-2">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="16" x2="12" y2="12"></line>
                    <line x1="12" y1="8" x2="12.01" y2="8"></line>
                  </svg>
                  Hint
                </button>
              </div>
            </div>
            
            <!-- Tab Content -->
            <div class="tab-content p-5">
              <div id="questionContent" class="text-gray-700"></div>
              <div id="hintContent" class="text-gray-700 hidden"></div>
            </div>
            
            <div class="absolute bottom-4 left-0 right-0 text-center text-gray-500 text-sm">
              Click to flip
            </div>
          </div>
          
          <!-- Back of Card -->
          <div class="flip-card-back rounded-xl shadow-lg">
            <div class="p-5 bg-gray-800 text-white flex justify-between items-center">
              <h3 id="cardTitleBack" class="font-bold text-xl"></h3>
            </div>
            
            <!-- Back Tabs -->
            <div class="border-b border-gray-600">
              <div class="flex">
                <button id="mnemonicTab" class="px-4 py-2 border-b-2 border-blue-300 text-blue-300 flex items-center gap-2">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path>
                    <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>
                  </svg>
                  Mnemonic
                </button>
                <button id="codeTab" class="px-4 py-2 border-b-2 border-transparent text-gray-300 flex items-center gap-2">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="16 18 22 12 16 6"></polyline>
                    <polyline points="8 6 2 12 8 18"></polyline>
                  </svg>
                  Code
                </button>
              </div>
            </div>
            
            <!-- Back Tab Content -->
            <div class="tab-content p-5">
              <div id="mnemonicContent" class="text-white"></div>
              <div id="codeContent" class="hidden">
                <pre id="codeBlock" class="font-mono text-sm bg-gray-900 p-4 rounded text-white"></pre>
              </div>
            </div>
            
            <div class="absolute bottom-4 left-0 right-0 text-center text-gray-400 text-sm">
              Click to flip back
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Footer -->
  <footer class="bg-gray-800 text-white p-4 mt-8">
    <div class="container mx-auto text-center text-sm">
      <p>Â© 2025 LeetCode Flashcards - Master Algorithms & Data Structures</p>
    </div>
  </footer>

  <script>
    // Data structure for topics and problems
    const topics = [
      { id: 'arrays', name: 'Arrays and Hashing' },
      { id: 'twopointers', name: 'Two Pointers' },
      { id: 'stack', name: 'Stack' },
      { id: 'binarysearch', name: 'Binary Search' },
      { id: 'slidingwindow', name: 'Sliding Window' },
      { id: 'linkedlist', name: 'Linked List' },
      { id: 'trees', name: 'Trees' },
      { id: 'tries', name: 'Tries' },
      { id: 'backtracking', name: 'Backtracking' },
      { id: 'heap', name: 'Heap/Priority Queue' },
      { id: 'intervals', name: 'Intervals' },
      { id: 'greedy', name: 'Greedy' },
      { id: 'advancedgraphs', name: 'Advanced Graphs' },
      { id: 'graphs', name: 'Graphs' },
      { id: 'dp1d', name: '1-D Dynamic Programming' },
      { id: 'dp2d', name: '2-D Dynamic Programming' },
      { id: 'bitmanipulation', name: 'Bit Manipulation' },
      { id: 'mathgeometry', name: 'Math & Geometry' },
    ];

    // Sample problems data
    const problems = {
      arrays: [
        {
          id: 'contains-duplicate',
          title: 'Contains Duplicate',
          difficulty: 'Easy',
          question: 'Given an integer array nums, return true if any value appears more than once in the array, otherwise return false.',
          hint: 'Think about using a data structure that allows for O(1) lookups.',
          mnemonic: 'The "Club Entry Check" - like a bouncer checking if someone is already inside the club (HashSet).',
          code: `def containsDuplicate(nums):
    seen = set()
    for num in nums:
        if num in seen:
            return True
        seen.add(num)
    return False

# Time Complexity: O(n)
# Space Complexity: O(n)`
        },
        {
          id: 'valid-anagram',
          title: 'Valid Anagram',
          difficulty: 'Easy',
          question: 'Given two strings s and t, return true if t is an anagram of s, and false otherwise. An anagram is a word formed by rearranging the letters of another word.',
          hint: 'Count the occurrences of each character in both strings.',
          mnemonic: 'The "Letter Counter" - like counting and comparing ingredients for two recipes.',
          code: `def isAnagram(s, t):
    if len(s) != len(t):
        return False
        
    char_count = {}
    
    # Count characters in s
    for char in s:
        char_count[char] = char_count.get(char, 0) + 1
        
    # Decrement counts for t
    for char in t:
        if char not in char_count or char_count[char] == 0:
            return False
        char_count[char] -= 1
        
    return True

# Time Complexity: O(n)
# Space Complexity: O(1) - as there are only 26 possible lowercase letters`
        },
        {
          id: 'two-sum',
          title: 'Two Sum',
          difficulty: 'Easy',
          question: 'Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.',
          hint: 'For each number, check if the complement (target - num) exists in the array.',
          mnemonic: 'The "Puzzle Piece Finder" - for each piece, look for its matching piece.',
          code: `def twoSum(nums, target):
    num_map = {}  # value -> index
    
    for i, num in enumerate(nums):
        complement = target - num
        if complement in num_map:
            return [num_map[complement], i]
        num_map[num] = i
        
    return []  # No solution found

# Time Complexity: O(n)
# Space Complexity: O(n)`
        },
        {
          id: 'group-anagrams',
          title: 'Group Anagrams',
          difficulty: 'Medium',
          question: 'Given an array of strings strs, group the anagrams together. Return the answer in any order.',
          hint: 'Think about how you can represent each string in a way that anagrams would have the same representation.',
          mnemonic: 'The "Word Sorter" - anagrams have the same sorted character sequence.',
          code: `def groupAnagrams(strs):
    groups = {}
    
    for s in strs:
        # Use sorted string as key
        key = ''.join(sorted(s))
        
        if key not in groups:
            groups[key] = []
        groups[key].append(s)
    
    return list(groups.values())

# Time Complexity: O(n * k log k) where n is the length of strs and k is the maximum length of a string in strs
# Space Complexity: O(n * k)`
        },
        {
          id: 'top-k-frequent',
          title: 'Top K Frequent Elements',
          difficulty: 'Medium',
          question: 'Given an integer array nums and an integer k, return the k most frequent elements.',
          hint: 'Count the frequency of each element and then find the k largest frequencies.',
          mnemonic: 'The "Top Charts" - like finding the most played songs in a playlist.',
          code: `from collections import Counter
import heapq

def topKFrequent(nums, k):
    # Count frequencies
    counter = Counter(nums)
    
    # Use heap to find k most frequent
    return heapq.nlargest(k, counter.keys(), key=counter.get)

# Time Complexity: O(n log k)
# Space Complexity: O(n)`
        }
      ],
      twopointers: [
        {
          id: 'valid-palindrome',
          title: 'Valid Palindrome',
          difficulty: 'Easy',
          question: 'A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward.',
          hint: 'Use two pointers: one starting from the beginning and one from the end.',
          mnemonic: 'The "Mirror Check" - like looking at a word from both sides to see if they match.',
          code: `def isPalindrome(s):
    left, right = 0, len(s) - 1
    
    while left < right:
        # Skip non-alphanumeric characters
        while left < right and not s[left].isalnum():
            left += 1
        while left < right and not s[right].isalnum():
            right -= 1
            
        # Compare characters (case-insensitive)
        if s[left].lower() != s[right].lower():
            return False
            
        left += 1
        right -= 1
        
    return True

# Time Complexity: O(n)
# Space Complexity: O(1)`
        },
        {
          id: 'two-sum-ii',
          title: 'Two Sum II - Input Array Is Sorted',
          difficulty: 'Medium',
          question: 'Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number.',
          hint: 'Since the array is sorted, you can use two pointers from both ends.',
          mnemonic: 'The "Converging Search" - like two people walking towards each other in a line.',
          code: `def twoSum(numbers, target):
    left, right = 0, len(numbers) - 1
    
    while left < right:
        current_sum = numbers[left] + numbers[right]
        
        if current_sum == target:
            return [left + 1, right + 1]  # 1-indexed
        
        if current_sum < target:
            left += 1
        else:
            right -= 1
    
    return []  # No solution found

# Time Complexity: O(n)
# Space Complexity: O(1)`
        }
      ],
      stack: [
        {
          id: 'valid-parentheses',
          title: 'Valid Parentheses',
          difficulty: 'Easy',
          question: 'Given a string s containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', determine if the input string is valid.',
          hint: 'Use a stack to keep track of opening brackets.',
          mnemonic: 'The "Bracket Matcher" - like pairing left and right gloves.',
          code: `def isValid(s):
    stack = []
    mapping = {")": "(", "}": "{", "]": "["}
    
    for char in s:
        if char in mapping:  # closing bracket
            top_element = stack.pop() if stack else '#'
            if mapping[char] != top_element:
                return False
        else:  # opening bracket
            stack.append(char)
    
    return not stack  # stack should be empty at the end

# Time Complexity: O(n)
# Space Complexity: O(n)`
        }
      ],
      binarysearch: [
        {
          id: 'binary-search',
          title: 'Binary Search',
          difficulty: 'Easy',
          question: 'Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums.',
          hint: 'Use the binary search algorithm by repeatedly dividing the search interval in half.',
          mnemonic: 'The "Phone Book Search" - like finding a name in a phone book by dividing pages.',
          code: `def search(nums, target):
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if nums[mid] == target:
            return mid
        
        if nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1  # Target not found

# Time Complexity: O(log n)
# Space Complexity: O(1)`
        }
      ],
      slidingwindow: [
        {
          id: 'best-time-to-buy-sell-stock',
          title: 'Best Time to Buy and Sell Stock',
          difficulty: 'Easy',
          question: 'You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy and a single day to sell.',
          hint: 'Keep track of the minimum price you\'ve seen so far, and calculate the maximum profit as you go through the array.',
          mnemonic: 'The "Bargain Hunter" - like buying at lowest price and selling at highest after.',
          code: `def maxProfit(prices):
    if not prices:
        return 0
        
    max_profit = 0
    min_price = float('inf')
    
    for price in prices:
        min_price = min(min_price, price)
        current_profit = price - min_price
        max_profit = max(max_profit, current_profit)
    
    return max_profit

# Time Complexity: O(n)
# Space Complexity: O(1)`
        }
      ],
      bitmanipulation: [
        {
          id: 'single-number',
          title: 'Single Number',
          difficulty: 'Easy',
          question: 'Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.',
          hint: 'Think about using bitwise operations. XOR has an interesting property: n ^ n = 0.',
          mnemonic: 'The "XOR Elimination" - like items canceling out in pairs, leaving the odd one out.',
          code: `def singleNumber(nums):
    result = 0
    for num in nums:
        result ^= num
    return result

# Time Complexity: O(n)
# Space Complexity: O(1)`
        },
        {
          id: 'number-of-1-bits',
          title: 'Number of 1 Bits',
          difficulty: 'Easy',
          question: 'Write a function that takes an unsigned integer and returns the number of 1 bits it has.',
          hint: 'You can use the n & (n-1) technique to count 1 bits efficiently.',
          mnemonic: 'The "Bit Counter" - like counting people in a crowd through a specific filter.',
          code: `def hammingWeight(n):
    count = 0
    while n:
        n &= (n - 1)  # This clears the least significant 1 bit
        count += 1
    return count

# Time Complexity: O(number of 1 bits)
# Space Complexity: O(1)`
        }
      ],
      dp1d: [
        {
          id: 'climbing-stairs',
          title: 'Climbing Stairs',
          difficulty: 'Easy',
          question: 'You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?',
          hint: 'Think about how many ways you can reach step n from steps n-1 and n-2.',
          mnemonic: 'The "Fibonacci Climber" - each step builds on previous choices.',
          code: `def climbStairs(n):
    if n <= 2:
        return n
        
    # Initialize first two steps
    dp = [0] * (n + 1)
    dp[1] = 1
    dp[2] = 2
    
    # Fill in the rest of the steps
    for i in range(3, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
        
    return dp[n]

# Time Complexity: O(n)
# Space Complexity: O(n)`
        }
      ]
      